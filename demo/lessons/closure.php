<?php

function Hello($name){
    echo "Hello, $name";
}
//todo Первый вариант вызвать функцию.
Hello("John");

//todo Но функцию также можно вызвать динамически.
$func = "Hello";
//todo Когда php видит обращение к переменной с параметром в круглых скобках,
// он подозревает что нужно бы вызвать функцию чье имя лежит в этой переменной.
$func("John");


//todo И есть третий вариант. При помощи анонимной функции.
// Это функция у которой нет имени, а в качестве имени используется
// имя переменной $x.
// Но тут в отличии от обычной функции важно в каком порядке в коде будет
// записана анонимная функция. Так как используется присвоение, то Php будет
// знать о функции лишь после ее записи, то есть код ее использующий обязан
// быть записан ниже ее. С использованием обычной функции таких проблем нет.
// Там не имеет значение порядок расположения декларации функции и кода ее
// использующего.
// В анонимной функции нам возвращается объект. Это на самом деле синтаксический
// сахар.

$x = function ($name){
            echo "Hello, $name";
        };

$x("John");


$arr = [1,2,3,4,5];

function foo($v){ return $v * 10;}

//todo При такой записи php использует foo() как функцию обратного вызова,
// при этом php сам будет бегать по массиву  $arr и сам забрасывать текущие
// значения в функцию foo().
// array_map — Применяет callback-функцию ко всем элементам указанных массивов.
$newArr = array_map("foo", $arr);

//todo Дело в том что функции в php суперглобальны, а таким способом можно
// добиться того что функция будет анонимной и локально используемой.
// Таким образом нет нужды создавать глобальные переменные.
$newArr2 = array_map(
    function ($v){
    return $v * 10;},
    $arr
);

//todo Closures - Замыкания - это и есть анонимные функции.
// Замыкание - это способность функции запирать вышестоящий контекст. Или
// знать о переменных которые определены не в ней а выше нее.
// В отличии от JS в PHP функции нужно принудительно объяснить чего и как
// замыкается.
// При помощи следующего синтаксиса мы можем заставить функцию видеть
// внешние переменные за декларированные выше нее.

$name = "John";
$closure = function() use($name) {
    echo $name;
};

$closure();

//todo Анонимную функцию в отличию от обычных функций мы можем возвращать,
// так как анонимная функция это объект.(ссылочный тип).
// Как это происходить в JS.
$add = function ($num){
  return function ($x) use($num){
      return $x * $num;
  };
};
//todo Таким образом в переменную $add_2 зашла готовая анонимная
// функция function ($x) которая сразу содержит в себе значение $num из внешней
// анонимной функции. И в дальнейшем уже при вызове $add_2 нам достаточно
// лишь ввести значение $x чтобы получить результат.
$add_2 = $add(2);
echo $add_2(2); // 4

//todo Чем это удобно? Допустим мы решили что не хотим умножать на 2 а хотим
// умножать на 5, тогда.
$add_5 = $add(5);
echo $add_5(2); // 10
//todo Таким образом нам не нужно везде использовать глобальные переменные,
// а можно использовать переменные из родительского контекста.

// Использование в классах
class User{
    private $_name;
    public function __construct($n){ $this->_name = $n;}
    public function greet($greeting){
        return function() use ($greeting) {
            return "$greeting {$this->_name}!";
        };
    }
}
$user = new User("John");
$en = $user->greet("Hello");
echo $en();